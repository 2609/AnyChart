#!/usr/bin/env python
#coding=utf-8

import os
import sys
import subprocess
import urllib
import zipfile
import platform
import shutil
import time
import re
#=======================================================================================================================
#           Project paths
#=======================================================================================================================
PROJECT_PATH = os.path.abspath(os.path.dirname(__file__))
CONTRIB_PATH = os.path.join(PROJECT_PATH, 'contrib')
COMPILER_PATH = os.path.join(CONTRIB_PATH, 'compiler', 'compiler.jar')
SRC_PATH = os.path.join(PROJECT_PATH, 'src')
TESTS_PATH =  os.path.join(PROJECT_PATH, 'tests')
OUT_PATH = os.path.join(PROJECT_PATH, 'out')
QUNIT_PATH = os.path.join(CONTRIB_PATH, 'qunit')
JSDOC_PATH = os.path.join(CONTRIB_PATH, 'jsdoc')
GRAPHICS_PATH = os.path.join(CONTRIB_PATH, 'graphics', 'src')
JSDOC_TEMPLATE_PATH = os.path.join(CONTRIB_PATH, 'api-reference-engine')
CLOSURE_LIBRARY_PATH = os.path.join(CONTRIB_PATH, 'closure-library')
CLOSURE_SOURCE_PATH = os.path.join(CLOSURE_LIBRARY_PATH, 'closure', 'goog')
CLOSURE_LINTER_WRAPPER_PATH = os.path.join(CONTRIB_PATH, 'closure-linter-wrapper')
CLOSURE_BIN_PATH = os.path.join(CLOSURE_LIBRARY_PATH, 'closure', 'bin')
DEPS_WRITER_PATH = os.path.join(CLOSURE_BIN_PATH, 'build', 'depswriter.py')
CLOSURE_BUILDER_PATH = os.path.join(CLOSURE_BIN_PATH, 'build', 'closurebuilder.py')
EXTERNS_PATH = os.path.join(PROJECT_PATH, 'externs')
DEMOS_PATH = os.path.join(PROJECT_PATH, 'demos')
ACDVF_PLAYGROUND_PATH = os.path.join(PROJECT_PATH, '..', 'ACDVF-playground-samples')

QUNIT_EXTERNS_PATH = os.path.join(EXTERNS_PATH, 'qunit-externs.js')
UTILS_EXTERNS_PATH = os.path.join(EXTERNS_PATH, 'utils-externs.js')
#=======================================================================================================================
#                            Synchronize contributions.
#=======================================================================================================================

def __has_closure_compiler():
    return os.path.exists(COMPILER_PATH)


def __has_closure_linter():
    hasLint = True
    try:
        subprocess.Popen(['gjslint'], shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    except StandardError:
        hasLint = False

    return hasLint


def __need_sync_contrib():
    return not __has_closure_compiler() or not __has_closure_linter()

def __sync_contrib():
    __checkPathExistence(CONTRIB_PATH)

    subprocess.call(['git', 'submodule', 'init'])
    subprocess.call(['git', 'submodule', 'update'])
    subprocess.call(['rm', '-f', '.git/hooks/post-checkout'])
    subprocess.call(['ln', '-s', '../../update-submodules', '.git/hooks/post-checkout'])

    #Download closure compiler
    if not __has_closure_compiler():
        print 'Download closure compiler'
        __download_and_unzip_from_http(
            'http://dl.google.com/closure-compiler/compiler-20131014.zip',
            'compiler'
        )

    #Install closure linter
    if not __has_closure_linter():
        print 'Install closure linter'
        isWin = platform.system() == 'Windows'
        commands = [] if isWin else ['sudo']
        commands.append('easy_install')
        commands.append('http://closure-linter.googlecode.com/files/closure_linter-latest.tar.gz')
        try:
            subprocess.call(commands)
        except StandardError:
            raise StandardError('Sync contribution failed: you should install easy_install module for python')

    print 'All contributions installed'


def __download_and_unzip_from_http(fromUrl, dirName):
    zObjPath = os.path.join(CONTRIB_PATH, dirName + '.zip')

    # download zip archive from url
    if not os.path.exists(zObjPath):
        urllib.urlretrieve(
            fromUrl,
            zObjPath
        )

    # extract zip archive
    targetPath = os.path.join(CONTRIB_PATH, dirName)
    __checkPathExistence(targetPath)
    zObj = zipfile.ZipFile(zObjPath)
    zObj.extractall(path=targetPath)
    zObj.close()

    # remove archive file
    os.remove(zObjPath)
    print 'Download successful'


def sync_required(func):
    def check():
        if __need_sync_contrib():
            raise StandardError('Failed: You should synchronize project contribution. \n See help for more info.')
        func()

    return check


def __checkPathExistence(path):
    if not os.path.exists(path):
        os.mkdir(path)


#=======================================================================================================================
#                            Compiler flags generation.
#=======================================================================================================================
class OptimizationLevel:
    NONE = 0
    SIMPLE = 1
    ADVANCED = 2


def __addOption(flags, flagName, flagValue):
    flags.append('--compiler_flags=--' + flagName + '=' + flagValue)


def __setPrettyPrint(flags):
    __addOption(flags, 'formatting', 'PRETTY_PRINT')


def __setOptimizationLevel(flags, level):
    #set compiler level
    if level == OptimizationLevel.NONE:
        levelValue = 'WHITESPACE_ONLY'
    elif level == OptimizationLevel.SIMPLE:
        levelValue = 'SIMPLE_OPTIMIZATIONS'
    elif level == OptimizationLevel.ADVANCED:
        levelValue = 'ADVANCED_OPTIMIZATIONS'
    else: levelValue = ''

    __addOption(flags, 'compilation_level', levelValue)


def __getOutputFileArg(outputFile):
    return ['--output_file=' + outputFile]


def __getNameSpaces():
    return ['--namespace=anychartexport']


def __getRoots(addTests=False):
    result = ['--root=%s' % SRC_PATH, '--root=%s' % CLOSURE_LIBRARY_PATH, '--root=%s' % GRAPHICS_PATH]
    if addTests:
        result.append('--root=%s' % TESTS_PATH)
    return result


def __getNotOptimizedCompilerArgs():
    compilerArgs = []
    __setOptimizationLevel(compilerArgs, OptimizationLevel.NONE)
    __setPrettyPrint(compilerArgs)
    return compilerArgs


def __getOptimizedCompilerArgs():
    compilerArgs = [
        '--compiler_flags=--warning_level=VERBOSE',
        '--compiler_flags=--generate_exports',
        '--compiler_flags=--jscomp_warning=deprecated',
        '--compiler_flags=--jscomp_warning=checkTypes',
        '--compiler_flags=--jscomp_warning=nonStandardJsDocs',
        '--compiler_flags=--jscomp_warning=checkRegExp',
        '--compiler_flags=--jscomp_warning=checkVars',
        '--compiler_flags=--jscomp_warning=invalidCasts',
        '--compiler_flags=--jscomp_warning=missingProperties',
        '--compiler_flags=--jscomp_warning=undefinedVars',
        '--compiler_flags=--jscomp_warning=duplicateMessage',
        '--compiler_flags=--jscomp_warning=globalThis',
        '--compiler_flags=--jscomp_warning=internetExplorerChecks',
        '--compiler_flags=--jscomp_warning=misplacedTypeAnnotation',
        '--compiler_flags=--jscomp_warning=suspiciousCode',
        '--compiler_flags=--jscomp_warning=strictModuleDepCheck',
        '--compiler_flags=--jscomp_warning=typeInvalidation',
        '--compiler_flags=--jscomp_warning=undefinedNames',
        '--compiler_flags=--jscomp_warning=unknownDefines',
        '--compiler_flags=--jscomp_warning=uselessCode',
        '--compiler_flags=--jscomp_warning=visibility',
        # uncomment to have some fun ;)
        #'--compiler_flags=--jscomp_warning=reportUnknownTypes',
    ]
    __setOptimizationLevel(compilerArgs, OptimizationLevel.ADVANCED)
    return compilerArgs


def __getDefaultCompilerArgs(addTests=False):
    result = [
        'python',
        CLOSURE_BUILDER_PATH,
        '--output_mode=compiled',
        '--compiler_jar=' + COMPILER_PATH,
        '--compiler_flags=--charset=UTF-8',
        '--compiler_flags=--define="goog.DEBUG=true"',
        '--compiler_flags=--define="anychart.VERSION=\'%s\'"' % __get_version(True),
        '--compiler_flags=--extra_annotation_name="includeDoc"',
        '--compiler_flags=--extra_annotation_name="illustration"',
        '--compiler_flags=--extra_annotation_name="illustrationDesc"',
        '--compiler_flags=--extra_annotation_name="ignoreDoc"',
        '--compiler_flags=--extra_annotation_name="propertyDoc"',
        '--compiler_flags=--extra_annotation_name="shortDescription"',
    ]

    if addTests:
        result.append('--compiler_flags=--externs=%s' % QUNIT_EXTERNS_PATH)

    return result

#=======================================================================================================================
#           Build project
#=======================================================================================================================
@sync_required
def __compileReleaseProjectFromCommandLine():

    #compile anychart.min.js
    __compileProjectFromCommandLine()

    #compile anychart.js
    outputFileName = os.path.join(OUT_PATH, 'anychart.js')
    commands = __getDefaultCompilerArgs() +\
               __getNotOptimizedCompilerArgs() +\
               __getNameSpaces() +\
               __getRoots() +\
               __getOutputFileArg(outputFileName)
    __call_compiler(commands, outputFileName)



@sync_required
def __compileProjectFromCommandLine():
    print "Compile components..."
    startDocsTimer = time.time()

    #Проверяем существует ли путь для выгрузки итогового файла, если нет, создаем.
    __checkPathExistence(OUT_PATH)

    #Сборка оптимизированной версии
    outputFileName = os.path.join(OUT_PATH, 'anychart.min.js')
    commands = __getDefaultCompilerArgs() +\
               __getOptimizedCompilerArgs() +\
               __getNameSpaces() +\
               __getRoots() +\
               __getOutputFileArg(outputFileName) +\
               ['--compiler_flags=--output_wrapper=(function(){%output%})()']

    __call_compiler(commands, outputFileName)
    print "[PY] compile time: {:.3f} sec".format(time.time() - startDocsTimer)

def __call_compiler(commands, outputFileName):
    tmp = 'Building graphics to ' + outputFileName
    p = subprocess.Popen(commands, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
    (output, err) = p.communicate()
    retcode = p.poll()
    print output

#=======================================================================================================================
#           Build deps
#=======================================================================================================================
@sync_required
def __buildDepsFromCommandLine():
    output_file = os.path.join(SRC_PATH, 'deps.js')
    __callDepsWriter(SRC_PATH, output_file, 'whole project')


def __callDepsWriter(root, output_file, bundle_name):
    print 'Writing deps for ' + bundle_name + ' to ' + output_file
    subprocess.call([
        'python',
        DEPS_WRITER_PATH,
        '--root_with_prefix=' + root + ' ' + os.path.relpath(root, CLOSURE_SOURCE_PATH),
        '--root_with_prefix=' + TESTS_PATH + ' ' + os.path.relpath(TESTS_PATH, CLOSURE_SOURCE_PATH),
        '--root_with_prefix=' + GRAPHICS_PATH + ' ' + os.path.relpath(GRAPHICS_PATH, CLOSURE_SOURCE_PATH),
        '--output_file=' + output_file
    ])

#=======================================================================================================================
#                            Linter.
#=======================================================================================================================
@sync_required
def __lintFromCommandLine():
    __callLinter(SRC_PATH)
    __callLinter(TESTS_PATH)
    __checkDocsOverridesErrors()


def __callLinter(root):
    print 'Linting ' + root + ' directory.\n'
    subprocess.call([
        'python',
        os.path.join(CLOSURE_LINTER_WRAPPER_PATH, 'gjslint.py'),
        '--flagfile',
        'gjslint.cfg',
        '-r',
        root
    ])

#Проверяем наличие ошибок в документации после автоформатирования кода в Idea/WebStrom
def __checkDocsOverridesErrors():
    print '============================================================='
    print '\nCheck overrides fails in docs'
    source = []
    MAINPATH = os.path.abspath(os.path.dirname(__file__))
    for dirname, dirnames, filenames in os.walk(os.path.join(MAINPATH, 'src')):
      for filename in filenames:
          source.append(os.path.join(dirname, filename))
    filesWithErrors = ""
    for filename in source:
        path = os.path.join(MAINPATH, filename)
        data = open(path).read()
        # для начала просто ищем косяк документации в файле
        if re.search('\*\/\n\/\*\*', data):
          filesWithErrors += path + " "
    print filesWithErrors.replace(' ', '\n')+'RUN AUTOFIX to fix this\n' if (len(filesWithErrors)>0) else 'ok'
#=======================================================================================================================
#                            JSDoc auto fix.
#=======================================================================================================================
@sync_required
def __autofixFromCommandLine():
    __callAutoFix(SRC_PATH)


def __callAutoFix(root):
    print 'Trying to autofix ' + root + ' directory.\n'
    subprocess.call([
        'python',
        os.path.join(CLOSURE_LINTER_WRAPPER_PATH, 'fixjsstyle.py'),
        '--flagfile',
        'gjslint.cfg',
        '-r',
        root
    ])
    #Чиним документацию, посе автоформатирования кода в Idea/WebStorm
    MAINPATH = os.path.abspath(os.path.dirname(__file__))
    source = []
    for dirname, dirnames, filenames in os.walk(os.path.join(MAINPATH, 'src')):
      for filename in filenames:
        source.append(os.path.join(dirname, filename))
    filesWithErrors = ""
    for filename in source:
        path = os.path.join(MAINPATH, filename)
        data = open(path).read()
        if re.search('\*\/\n\/\*\*', data):
          filesWithErrors += path + " "
          o = open(path, "w")
          o.write(re.sub('\*\/\n\/\*\*', '*//**' , data))
          o.close()
          print "fixied "+path

#=======================================================================================================================
#                            JSDoc build.
#=======================================================================================================================
@sync_required
def __buildJSDocFromCommandLine():
    __buildDocs()


def __buildDocs():
    FLAG_NEEDS_TREE = "";
    CUSTOM_SRC = "";
    PROFILER = "";
    CHECK_ONLY = "";
    GENERATE_PLAYGROUND_SAMPLES = "";
    IS_RELEASE = "";

    # Компилируем код, если вызван ключ
    buildSetting = "";
    args = sys.argv
    if ('--release' in args[2:]):
      IS_RELEASE = "1";
      buildSetting += "\tRELEASE build\n"
    if ('-chk' in args[2:]):
      CHECK_ONLY = "1"
      buildSetting += "\tcheck-only mode\n"
    if ('-c' in args[2:]):
      __compileProjectFromCommandLine()
    if ('-t' in args[2:] or IS_RELEASE):
      FLAG_NEEDS_TREE = "1";
      buildSetting += "\tgenerate tree of classes\n"
    if ('-p' in args[2:]):
      PROFILER = "1";
      buildSetting += "\tJS profiler on\n"
    if ('-g' in args[2:] or IS_RELEASE):
      GENERATE_PLAYGROUND_SAMPLES = "1";
      buildSetting += "\tgenerate playground samples\n"
    if ('-src' in args[2:] and not IS_RELEASE):
      if (len(args)-1 == args.index('-src')):
        print 'Надо указать модуль'
        return 0
      CUSTOM_SRC = args[args.index('-src')+1]

    DOCS_OUT_PATH = os.path.join(OUT_PATH, 'docs')
    __checkPathExistence(OUT_PATH)
    __checkPathExistence(DOCS_OUT_PATH)

    print "JSDoc with settings:\n"+buildSetting
    if (len(CHECK_ONLY) == 0):
      if (len(CUSTOM_SRC) > 0):
         print "\tonly package:"+CUSTOM_SRC+"\n"
      # clear dir: out/docs/version
      if IS_RELEASE:
        DOCS_OUT_PATH = os.path.join(DOCS_OUT_PATH, __get_version())
      else:
        DOCS_OUT_PATH = os.path.join(DOCS_OUT_PATH, 'master')
      __checkPathExistence(DOCS_OUT_PATH)
      shutil.rmtree(DOCS_OUT_PATH)
      os.mkdir(DOCS_OUT_PATH)
      os.mkdir(os.path.join(DOCS_OUT_PATH,'scripts'))
      shutil.copy(os.path.join(OUT_PATH, 'anychart.min.js'), os.path.join(DOCS_OUT_PATH, 'scripts', 'anychart.min.js'))

    p = subprocess.Popen(
        ['git', 'tag'],
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        cwd=PROJECT_PATH)
    (output, err) = p.communicate()
    TAG_LIST = output.strip()

    # write commindLine parameters
    # !!! order strictly required !!!
    f=open(os.path.join(DOCS_OUT_PATH,'commandLine.opts'), 'w')
    f.write("\n".join([
      FLAG_NEEDS_TREE,
      CUSTOM_SRC,
      PROFILER,
      CHECK_ONLY,
      '","'.join(TAG_LIST.split('\n')),
      GENERATE_PLAYGROUND_SAMPLES
      # EXPORTS write here
    ]))
    f.close()

    PLAYGRAUND_SAMPLES_DIR = os.path.join(CONTRIB_PATH, 'docs-playground-samples', 'api')
    if (GENERATE_PLAYGROUND_SAMPLES == "1"):
        print 'GIT: update contrib with samples'
        p = subprocess.Popen(
            "git checkout master && git pull origin master",
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            shell=True,
            cwd=PLAYGRAUND_SAMPLES_DIR)
        (output, err) = p.communicate()
        if not (p.returncode == 0):
          print "exit-code: %d\n  err: %s\n output: %s" % (p.returncode, err, output)
        # clear directory
        shutil.rmtree(PLAYGRAUND_SAMPLES_DIR)
        os.mkdir(PLAYGRAUND_SAMPLES_DIR)

    # running JSDoc engine
    startDocsTimer = time.time()
    subprocess.call([
        os.path.join(JSDOC_TEMPLATE_PATH, 'jsdoc'),
        SRC_PATH,
        '-r',
        '-t',
        os.path.join(JSDOC_TEMPLATE_PATH, 'templates', 'main'),
        '-c',
        os.path.join(JSDOC_TEMPLATE_PATH, 'conf.json'),
        '-d', DOCS_OUT_PATH,
        '-l'],
        shell=(platform.system() == 'Windows'))
    os.remove(os.path.join(DOCS_OUT_PATH,'commandLine.opts'));
    print "[PY] build docs time: {:.3f} sec".format(time.time() - startDocsTimer)

    if (GENERATE_PLAYGROUND_SAMPLES == "1"):
        print 'GIT: trying push samples'
        p = subprocess.Popen(
            "git add -A && git commit -am 'autobuild samples' && git push origin master",
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            shell=True,
            cwd=PLAYGRAUND_SAMPLES_DIR)
        (output, err) = p.communicate()
        if not (p.returncode == 0):
          print "exit-code: %d\n  err: %s\n output: %s" % (p.returncode, err, output)

    print "\nAll done! Bye-bye! :)"
#=======================================================================================================================
#                            Logging.
#=======================================================================================================================
warnings_list = []

def __print_no_bundles():
    print 'No bundles found, see help for more info. (python build --help)'


def __print_warnings_list():
    for msg in warnings_list:
        print "\nWarning:"
        print msg


#=======================================================================================================================
#                  Converting samples from demos to playground format and deploy changes.
#=======================================================================================================================
def __convert_demos_to_playground():
    if not os.path.exists(ACDVF_PLAYGROUND_PATH):
        print 'Error: No ACDVF-playground-samples repo found'
        print 'You should clone playground repo to ' + ACDVF_PLAYGROUND_PATH
        return

    for root, dirs, files in os.walk(DEMOS_PATH):
        if "/demos/dev" not in root:
            category_name = root.replace(DEMOS_PATH, '').replace('/', '')
            pg_category_path = os.path.join(ACDVF_PLAYGROUND_PATH, category_name)

            __checkPathExistence(pg_category_path)

            for sample in files:
                if sample.endswith('.js'):
                    sample_name = os.path.splitext(os.path.basename(sample))[0] + '.sample'
                    pg_sample_path = os.path.join(pg_category_path, sample_name)

                    f = open(os.path.join(root, sample), 'r')
                    sample_text = f.read()
                    f.close()
                    sample_text = sample_text.replace('var chart', 'chart')
                    sample_text = "$('#container').width(600).height(400);\n\n" + sample_text

                    if os.path.exists(pg_sample_path):
                        f = open(os.path.join(root, pg_sample_path), 'r')
                        pg_sample_text = f.read()
                        f.close()

                        search_result = re.findall('^.[\n\s:a-zA-Z\[\]_"]*}', pg_sample_text)
                        if len(search_result):
                            sample_settings = search_result[0]
                            result = sample_settings + '\n' + sample_text
                        else:
                            result = '{:tags []\n  :is_new true\n  :exports "chart"}\n' + sample_text
                    else:
                        result = '{:tags []\n  :is_new true\n  :exports "chart"}\n' + sample_text

                    f = open(pg_sample_path, 'w+')
                    f.flush()
                    f.write(result)
                    f.close()


#=======================================================================================================================
#                            Version.
#=======================================================================================================================
def __get_version(opt_commit_count=False):
    #get global, major, minor versions from version.ini
    version_file = os.path.join(PROJECT_PATH, 'version.ini')
    f = open(version_file, 'r')
    lines = f.readlines()
    f.close()

    globalVersion = lines[0].split('=')[1].strip()
    major = lines[1].split('=')[1].strip()
    minor = lines[2].split('=')[1].strip()

    if opt_commit_count:
        #get commits count from git repo
        p = subprocess.Popen(
            ['git', 'rev-list', 'HEAD', '--count'],
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            cwd=PROJECT_PATH)
        (output, err) = p.communicate()
        commit_count = output.strip()

        return "%s.%s.%s.%s" % (globalVersion, major, minor, commit_count)
    else:
        return "%s.%s.%s" % (globalVersion, major, minor)


#=======================================================================================================================
#                            Help.
#=======================================================================================================================


def __printHelp():
    print "Команды выполняемые скриптом:\n"\
            "\n"\
          "contrib          Сборка всех зависимостей проекта, таких как внешние билбиотеки, \n"\
          "                 компилятор, и другие утилитные вещи. (python build contrib) \n"\
            "\n"\
          "deps             Генерация dependencies как для продуктовых модулей по отдельности,\n"\
          "                 так и для всего проекта (python build deps).\n"\
            "\n"\
          "compile            Сборка продуктовых модулей  (python build compile).\n"\
            "\n"\
          "lint             Проверка кода на соответствие google JavaScript style guide (python build lint)\n"\
            "\n"\
          "autofix          Исправление не соответствией кода google JavaScript style guide (python build autofix).\n"\
          "                 Это эксперементальная функция. За ней нужно всегда проверять что же она там наисправляла\n"\
            "\n"\
          "docs             Сборка документации по продуктовому модулю или по всему проекту (python build docs)."\
              "\n\t"\
            "-c       Выполнит compile перед сборкой документации.\n"\
              "\n\t"\
            "-t       Соберет tree.js для UMLjs.\n"\
              "\n\t"\
            "-p       Включает внутренний профайлер.\n"\
              "\n\t"\
            "-src PACKAGE_NAME      Выполнит сборку документации только укащанного package.\n"\
              "\n\t"\
            "-chk     Выполнит проверку и не будет билдить документации. Игнорирует все флаги кроме -src.\n"\
              "\n\t"\
            "-g       Включает генерацию сэмплов плейграунда.\n"\
              "\n\t"\
            "--release Автоматически расставляет необходимые настройки.\n"\
              "\n\t"\


#=======================================================================================================================
#           Main
#=======================================================================================================================
def __execMainScript():
    args = sys.argv
    if len(args) == 1:
        __printHelp()
    elif args[1] == 'help' or args[1] == '--help' or args[1] == '-h':
        __printHelp()
    elif args[1] == 'contrib':
        __sync_contrib()
    elif args[1] == 'compile':
        __compileProjectFromCommandLine()
    elif args[1] == 'compile-release':
        __compileReleaseProjectFromCommandLine()
    elif args[1] == 'deps':
        __buildDepsFromCommandLine()
    elif args[1] == 'lint':
        __lintFromCommandLine()
    elif args[1] == 'autofix':
        __autofixFromCommandLine()
    elif args[1] == 'docs':
        __buildJSDocFromCommandLine()
    elif args[1] == 'convert-pg':
        __convert_demos_to_playground()
    else:
        __printHelp()

    __print_warnings_list()

if __name__ == '__main__':
    try:
        __execMainScript()
    except StandardError as e:
        print e
